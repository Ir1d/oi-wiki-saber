(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{78:function(n,t,e){"use strict";e.r(t);var a=e(0),r=function(n){var t,e,a=(t=void 0,e="例题八数码",{attributes:{slug:"search/astar",layout:"post",permalink:"/search/astar",createdAt:new Date(1561448967534),updatedAt:new Date(1561448967534),type:"page",assets:{}},internal:t,contentType:"markdown",content:t,markdownHeadings:[{text:e,slug:e,level:2},{text:"例题 k 短路",slug:"例题-k-短路",level:2}],excerpt:'<p>A*算法是 <saber-link to="/search/bfs">BFS</saber-link> 的一种改进。</p>\n'}),r=n.options.beforeCreate||[];n.options.beforeCreate=[function(){this.$page=a}].concat(r);["layout","transition"].forEach(function(t){var e=n.options.PageComponent;e&&(n.options[t]=e[t]),void 0===n.options[t]&&(n.options[t]=a.attributes[t])}),n.options.name="page-wrapper-"+a.attributes.slug.replace(/[^0-9a-z\-]/i,"-")},i=Object(a.a)({},function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("layout-manager",[e("p",[n._v("A*算法是 "),e("saber-link",{attrs:{to:"/search/bfs"}},[n._v("BFS")]),n._v(" 的一种改进。")],1),n._v(" "),e("p",[n._v("定义起点 $s$ ，终点 $t$ 。")]),n._v(" "),e("p",[n._v("从起点（初始状态）开始的距离函数 $g(x)$ 。")]),n._v(" "),e("p",[n._v("到终点（最终状态）的距离函数 $h(x), h*(x)$ 。")]),n._v(" "),e("p",[n._v("定义每个点的估价函数 $f(x)=g(x)+h(x)$ 。")]),n._v(" "),e("p",[n._v("A*算法每次从 "),e("strong",[n._v("优先队列")]),n._v(" 中取出一个 $f$ 最小的，然后更新相邻的状态。")]),n._v(" "),e("p",[n._v("如果 $h\\leq h*$ ，则 A*算法能找到最优解。")]),n._v(" "),e("p",[n._v("上述条件下，如果 $h$  "),e("strong",[n._v("满足三角形不等式，则 A*算法不会将重复结点加入队列")]),n._v(" 。")]),n._v(" "),e("p",[n._v("其实…… $h=0$ 时就是 "),e("saber-link",{attrs:{to:"/search/dfs"}},[n._v("DFS")]),n._v(" 算法， $h=0$ 并且边权为 $1$ 时就是 "),e("saber-link",{attrs:{to:"/search/bfs"}},[n._v("BFS")]),n._v("。")],1),n._v(" "),e("h2",{attrs:{id:"例题八数码"}},[n._v("例题"),e("a",{attrs:{href:"https://www.luogu.org/problemnew/show/P1379",target:"_blank",rel:"noopener noreferrer"}},[n._v("八数码")])]),n._v(" "),e("p",[n._v("题目大意：在 $3\\times 3$ 的棋盘上，摆有八个棋子，每个棋子上标有 1 至 8 的某一数字。棋盘中留有一个空格，空格用 0 来表示。空格周围的棋子可以移到空格中，这样原来的位置就会变成空格。给出一种初始布局和目标布局（为了使题目简单，设目标状态为")]),n._v(" "),e("pre",[e("code",[n._v("123\n804\n765\n")])]),n._v(" "),e("p",[n._v("），找到一种从初始布局到目标布局最少步骤的移动方法。")]),n._v(" "),e("p",[n._v("$h$ 函数可以定义为，不在应该在的位置的数字个数。")]),n._v(" "),e("p",[n._v("容易发现 $h$ 满足以上两个性质，此题可以使用 A*算法求解。")]),n._v(" "),e("p",[n._v("代码实现：")]),n._v(" "),e("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"cpp"}},[e("pre",{pre:!0,attrs:{class:"saber-highlight-code language-cpp"}},[e("code",{pre:!0,attrs:{class:"language-cpp"}},[n._v('#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <set>\nusing namespace std;\nconst int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};\nint fx, fy;\nchar ch;\nstruct matrix {\n  int a[5][5];\n  bool operator<(matrix x) const {\n    for (int i = 1; i <= 3; i++)\n      for (int j = 1; j <= 3; j++)\n        if (a[i][j] != x.a[i][j]) return a[i][j] < x.a[i][j];\n    return false;\n  }\n} f, st;\nint h(matrix a) {\n  int ret = 0;\n  for (int i = 1; i <= 3; i++)\n    for (int j = 1; j <= 3; j++)\n      if (a.a[i][j] != st.a[i][j]) ret++;\n  return ret;\n}\nstruct node {\n  matrix a;\n  int t;\n  bool operator<(node x) const { return t + h(a) > x.t + h(x.a); }\n} x;\npriority_queue<node> q;\nset<matrix> s;\nint main() {\n  st.a[1][1] = 1;\n  st.a[1][2] = 2;\n  st.a[1][3] = 3;\n  st.a[2][1] = 8;\n  st.a[2][2] = 0;\n  st.a[2][3] = 4;\n  st.a[3][1] = 7;\n  st.a[3][2] = 6;\n  st.a[3][3] = 5;\n  for (int i = 1; i <= 3; i++)\n    for (int j = 1; j <= 3; j++) {\n      scanf(" %c", &ch);\n      f.a[i][j] = ch - \'0\';\n    }\n  q.push({f, 0});\n  while (!q.empty()) {\n    x = q.top();\n    q.pop();\n    if (!h(x.a)) {\n      printf("%d\\n", x.t);\n      return 0;\n    }\n    for (int i = 1; i <= 3; i++)\n      for (int j = 1; j <= 3; j++)\n        if (!x.a.a[i][j]) fx = i, fy = j;\n    for (int i = 0; i < 4; i++) {\n      int xx = fx + dx[i], yy = fy + dy[i];\n      if (1 <= xx && xx <= 3 && 1 <= yy && yy <= 3) {\n        swap(x.a.a[fx][fy], x.a.a[xx][yy]);\n        if (!s.count(x.a)) s.insert(x.a), q.push({x.a, x.t + 1});\n        swap(x.a.a[fx][fy], x.a.a[xx][yy]);\n      }\n    }\n  }\n  return 0;\n}')])])]),e("h2",{attrs:{id:"例题-k-短路"}},[n._v("例题 "),e("a",{attrs:{href:"https://www.luogu.org/problemnew/show/P2483",target:"_blank",rel:"noopener noreferrer"}},[n._v("k 短路")])]),n._v(" "),e("p",[n._v("题目大意：按顺序求一个有向图上从结点 $s$ 到结点 $t$ 的所有路径最小的前任意多（不妨设为 $k$ ）个。")]),n._v(" "),e("p",[n._v("很容易发现，这个问题很容易转化成用 A*算法解决问题的标准程式。")]),n._v(" "),e("p",[n._v("初始状态为处于结点 $s$ ，最终状态为处于结点 $t$ ，距离函数为从 $s$ 到当前结点已经走过的距离，估价函数为从当前结点到结点 $t$ 至少要走过的距离，也就是当前结点到结点 $t$ 的最短路。")]),n._v(" "),e("p",[n._v("就这样，我们在预处理的时候反向建图，计算出结点 $t$ 到所有点的最短路，然后将初始状态塞入优先队列，每次取出 $f(x)=g(x)+h(x)$ 最小的一项，计算出其所连结点的信息并将其也塞入队列。当你第 $k$ 次走到结点 $t$ 时，也就算出了结点 $s$ 到结点 $t$ 的 $k$ 短路。")]),n._v(" "),e("p",[n._v("由于设计的距离函数和估价函数，每个状态需要存储两个参数，当前结点 $x$ 和已经走过的距离 $v$ 。")]),n._v(" "),e("p",[n._v("我们可以在此基础上加一点小优化：由于只需要求出第 $k$ 短路，所以当我们第 $k+1$ 次或以上走到该结点时，直接跳过该状态。因为前面的 $k$ 次走到这个点的时候肯定能因此构造出 $k$ 条路径，所以之后在加边更无必要。")]),n._v(" "),e("p",[n._v("代码实现：")]),n._v(" "),e("div",{pre:!0,attrs:{class:"saber-highlight","data-lang":"cpp"}},[e("pre",{pre:!0,attrs:{class:"saber-highlight-code language-cpp"}},[e("code",{pre:!0,attrs:{class:"language-cpp"}},[n._v('#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int maxn = 5010;\nconst int maxm = 400010;\nconst double inf = 2e9;\nint n, m, k, u, v, cur, h[maxn], nxt[maxm], p[maxm], cnt[maxn], ans;\nint cur1, h1[maxn], nxt1[maxm], p1[maxm];\ndouble e, ww, w[maxm], f[maxn];\ndouble w1[maxm];\nbool tf[maxn];\nvoid add_edge(int x, int y, double z) {\n  cur++;\n  nxt[cur] = h[x];\n  h[x] = cur;\n  p[cur] = y;\n  w[cur] = z;\n}\nvoid add_edge1(int x, int y, double z) {\n  cur1++;\n  nxt1[cur1] = h1[x];\n  h1[x] = cur1;\n  p1[cur1] = y;\n  w1[cur1] = z;\n}\nstruct node {\n  int x;\n  double v;\n  bool operator<(node a) const { return v + f[x] > a.v + f[a.x]; }\n};\npriority_queue<node> q;\nstruct node2 {\n  int x;\n  double v;\n  bool operator<(node2 a) const { return v > a.v; }\n} x;\npriority_queue<node2> Q;\nint main() {\n  scanf("%d%d%lf", &n, &m, &e);\n  while (m--) {\n    scanf("%d%d%lf", &u, &v, &ww);\n    add_edge(u, v, ww);\n    add_edge1(v, u, ww);\n  }\n  for (int i = 1; i < n; i++) f[i] = inf;\n  Q.push({n, 0});\n  while (!Q.empty()) {\n    x = Q.top();\n    Q.pop();\n    if (tf[x.x]) continue;\n    tf[x.x] = true;\n    f[x.x] = x.v;\n    for (int j = h1[x.x]; j; j = nxt1[j]) Q.push({p1[j], x.v + w1[j]});\n  }\n  k = (int)e / f[1];\n  q.push({1, 0});\n  while (!q.empty()) {\n    node x = q.top();\n    q.pop();\n    cnt[x.x]++;\n    if (x.x == n) {\n      e -= x.v;\n      if (e < 0) {\n        printf("%d\\n", ans);\n        return 0;\n      }\n      ans++;\n    }\n    for (int j = h[x.x]; j; j = nxt[j])\n      if (cnt[p[j]] <= k && x.v + w[j] <= e) q.push({p[j], x.v + w[j]});\n  }\n  printf("%d\\n", ans);\n  return 0;\n}')])])])])},[],!1,null,null,null);"function"==typeof r&&r(i);t.default=i.exports}}]);